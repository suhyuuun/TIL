# CHAPTER4 데이터베이스
## SECTION1 데이터베이스의 기본
- 데이터베이스(DB, DataBase) : 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음
- DBMS(DataBase Managemnet System) : 해당 데이터베이스를 제어, 관리하는 통합 시스템
- 데이터베이스 안에 있는 데이터들은 특정 DBMS마다 정의된 쿼리 언어를 통해 삽입, 삭제, 수정, 조회 등을 수행할 수 있음
- 실시간 접근과 동시 공유 가능

### 4.1.1 엔터티 (entity)
- 사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사 의미
- 약한 엔터티와 강한 엔터티  
  
### 4.1.2 릴레이션 (relation)
- 데이터베이스에서 정보를 구분하여 저장하는 기본 단위
- 엔터티에 관한 데이터를 데이터베이스는 릴레이션 하나에 담아서 관리
- 관계형 데이터베이스 : 테이블
- NoSQL 데이터베이스 : 컬렉션

- 테이블과 컬렉션
  - 관계형 데이터베이스
    - Ex) MySQL
    - 레코드-테이블-데이터베이스
  - NoSQL 데이터베이스
    - Ex) MongoDB
    - 도큐먼트-컬렉션-데이터베이스

### 4.1.3 속성 (attribute)
- 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보

### 4.1.4 도메인 (domain)
- 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합

### 4.1.5 필드와 레코드
- 필드
  - 숫자타입
    - Ex) TINYNT, SMALLINT, INT, BIGINT
  
  - 날짜타입
    - DATE : 날찌 부분은 있지만 시간 부분은 없는 값에 사용
    - DATETIME : 날짜 및 부분을 모두 포함하는 값에 사용됨, 8바이트
    - TIMESTAMP : 날짜 및 시간 부분을 모두 포함하는 값에 사용, 4바이트
  - 문자타입
    - CHAR와 VARCHAR
      - CHAR
        - 고정 길이 문자열
        - 길이는 0에서 255 사이의 값을 가짐
        - 레코드를 저장할 때 무조건 선언한 길이 값 -> '고정'해서 저장
        - 유동적이지 않은 길이를 가진 데이터의 경우에 효율적
      - VARCHAR
        - 가변 길이 문자열
        - 길이는 0에서 65535 사이의 값으로 지정
        - 입력된 데이터에 따라 용량을 가변시켜 저장
        - 유동적인 길이를 가진 데이터

    - TEXT와 BLOB : 큰 데이터를 저장할 때 쓰는 타입
      - TEXT
        - 큰 문자열 저장에 쓰이며 주로 게시판의 본문 저장시 사용
      - BLOB
        - 이미지, 동영상 등 큰 데이터 저장에 사용

    - ENUM과 SET
        - ENUM
          - ENUM형태로 쓰이며 하나만 선택하는 단일 선택만 가능
          - ENUM 리스트에 없는 잘못된 값 삽입시 빈 문자열이 대신 삽입
        - SET
          - 여러 개의 데이터 선택가능
          - 비트 단위의 연산 가능
          - 최대 64개의 요소를 집어넣을 수 있다는 점이 다름

      - 장점 : 공간적 이점
      - 단점 : 애플리케이션의 수정에 따라 데이터베이스의 ENUM이나 SET에서 정의한 목록 수정해야함

- 레코드(record) : 테이블에 쌓이는 행(row)단위의 데이터, 튜플이라고도 함

### 4.1.6 관계
- 1:1 관계 : 테이블을 두 개의 테이블로 나눠 테이블의 구조를 더 이해하기 쉽게 만들어 줌
- 1:N 관계 : 한 개체가 다른 많은 개체를 포함하는 관계
- N:M 관계
  - 테이블 두 개를 직접적으로 연결해서 구축하지 않음
  - 1:N, 1:M이라는 관계를 갖는 테이블 두 개로 나눠서 설정

### 4.1.7 키
- 기본키(Primary Key)
  - PK 또는 프라이머리키
  - 유일성과 최소성을 만족하는 키
  - 테이블의 데이터 중 고유하게 존재하는 속성
    - 자연키
      - 중복된 값들을 제외하며 중복되지 않는 것
      - 언젠가는 변하는 속성을 가짐
    - 인조키
      - 오라클 : sequence, MySQL : auto increment
      - 고유 식별자
      - 인위적으로 생성한 키
      - 자연키와 대조적으로 변하지 않음
      - 보통 기본키는 인조키로 설정

- 외래키(Foreign Key)
  - FK
  - 다른 테이블의 기본키를 그대로 참조하는 값
  - 개체와의 관계를 식별하는 데 사용

- 후보키
  - 기본키가 될 수 있는 후보
  - 유일성과 최소성을 동시에 만족

- 대체키
  - 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들

- 슈퍼키
  - 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키

## SECTION2 ERD와 정규화 과정
- ERD(Entity Relationship Diagram)
  - 데이터베이스를 구축할 때 가장 기초적인 뼈대 역할
  - 릴레이션 간의 관계들을 정의

### 4.2.1 ERD의 중요성
- 시스템의 요구 사항을 기반으로 작성
- ERD 기반으로 데이터베이스를 구축
  - 데이터베이스를 구축한 이후에도 디버깅 또는 비즈니스 프로세스 재설계가 필요한 경우에 설계도 역할을 당담하기도 함
- 장점 : 관계형 구조로 표현할 수 있는 데이터를 구성하는 데 유용
- 단점 : 비정형 데이터를 충분히 표현불가
  - 비정형 데이터 : 비구조화 데이터

### 4.2.2 예제로 배우는 ERD

### 4.2.3 정규화 과정
- 정규화 과정
  - 릴레이션 간의 잘못된 종송 관계로 인해 데이터베이스 이상 현상이 일어나서 이를 해결
  - 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정
  - 정규형 원칙을 기반으로 정규형을 만들어가는 과정
  - 정규화된 정도는 정규형(NF, Normal Form)으로 표현
  
- 데이터베이스 이상 현상
  - 회원이 한 개의 등급을 가져야 하는데 세 개의 등급을 갖거나 삭제할 때 필요한 데이터가 같이 삭제되고, 데이터를 삽입해야 하는데 하나의 필드 값이 NULL이 되면 안되어서 삽입하기 어려운 현상

- 정규형 원칙
  - 같은 의미를 표현하는 릴레이션이지만 
    - 좀 더 좋은 구조로 만들어야 함
    - 자료의 중복성 감소해야 함
    - 독립적인 관계는 별개의 릴레이션으로 표현해야 함
    - 각각의 릴레이션은 독립적인 표현이 가능해야 함

- 제1정규형
  - 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값(atomic value)만으로 구성되어야 함
  - 릴레이션의 속성 값 중 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안됨
    - 만약 반복 집합이 있다면 제거

- 제2정규형
  - 릴레이션이 제 1정규형이며 부분 함수의 종속성을 제거한 형태
  - 부분 함수의 종속성 제거
    - 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것
  - 주의할 점
    - 릴레이션 분해 시 동등한 릴레이션으로 분해
    - 정보 손실이 발생하지 않는 무손실 분해되어야 함

- 제3정규형
  - 제2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않는 상태

- 보이스/코드 정규형
  - 제3정규형이고 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태

## SECTION3 트랜잭션과 무결성
### 4.3.1 트랜잭션
- 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위
- 데이터베이스에 접근하는 방법은 쿼리 -> 여러 개의 쿼리들을 하나로 묶는 단위
- 원자성, 일관성, 독립성, 지속성
- 모든 특징이 있는 경우 -> ACID
  - 원자성(atomicity)
    - 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징
    - all or nothing
    - 커밋과 롤백
      - 커밋(commit)
        - 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
        - 트랜잭션 단위로 수행 -> 변경된 내용이 모두 영구적으로 저장되는 것
        - update, insert, delete의 쿼리가 하나의 트랜잭션 단위로 수행 / 이후 데이터베이스에 영구 저장
      - 롤백(rollback)
        - 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일(취소)

    - 데이터의 무결성 보장
    - 데이터 변경 전 변경 사항을 쉽게 확인가능, 해당 작업 그룹화

    - 트랜잭션 전파
      - 트랜잭션을 수행할 때 커넥션 단위로 수행하기 때문에 커넥션 객체를 넘겨서 수행
      - 이를 넘겨서 수행하지 않고 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것

  - 일관성(consistency)
    - 허용된 방식으로만 데이터를 변경해야 하는 것
    - 데이터베이스에 기록된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야 함

  - 격리성(isolation)
    - 트랜잭션 수행 시 서로 끼어들지 못하는 것
    - 여러 개의 격리 수준으로 나뉘어 격리성 보장
    - 격리 수준에 따라 발생하는 현상
      - 팬텀 리드(phantom read)
        - 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우
      - 반복 가능하지 않은 조회
        - 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우
      - 더티 리드
        - 반복 가능하지 않은 조회와 유사
        - 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었으나 아직 '커밋되지 않은' 행의 데이터를 읽을 수 있을 때 발생
    - 격리 수준
      - SERIALIZABLE
        - 말 그대로 트랜잭션을 순차적으로 진행시키는 것
        - 여러 트랜잭션이 동시에 같은 행 접근할 수 없음
        - 교착 상태가 일어날 확률도 많고 가장 성능이 떨어지는 격리 수준
      - REPEATABLE_READ
        - 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행을 추가하는 것은 막지 않음
      - READ_COMMITTED
        - 가장 많이 사용되는 격리 수준
        - MySQL8.0, PostgreSQL, SQL server, 오라클에서 기본갑스올 설정
        - READ_UNCOMMITTED와는 달리 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없음
        - 커밋 완료된 데이터에 대해서만 조회 허용
      - READ_UNCOMMITTED
        - 가장 낮은 격리 수준
        - 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠름
        - 데이터 무결성을 위해 되도록이면 사용하지 않는 것이 이상적
        - 몇몇 행이 제대로 조회되지 않더라도 괜찮은 거대한 양의 데이터를 '어림잡아' 집계하는 데는 사용하면 좋음

  - 지속성(durability)
    - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것
    - 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능이 있어야 함
    - 데이터베이스는 이를 위해 체크섬, 저널링, 롤백 등의 기능 제공

### 4.3.2 무결성
- 데이터의 정확성, 일관성, 유효성을 유지하는 것
- 무결성이 유지되어야 데이터베이스에 저장된 데이터 값과 그 값에 해당하는 현실 세계의 실제 값이 일치하는지에 대한 신뢰가 생김
- 종류
  - 개체 무결성 : 기본키로 선택된 필드는 빈 값을 허용하지 않음
  - 참조 무결성 : 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 함
  - 고유 무결성 : 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성은 모두 고유한 값을 가짐
  - NULL 무결성 : 특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약조건

## SECTION4 데이터베이스의 종류
### 4.4.1 관계형 데이터베이스
- 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스
- SQL이라는 언어를 써서 조작
- Ex) MySQL, PostgreSQL, 오라클, SQLServer, MSSQL 등

- MySQL
  - 대부분의 운영체제와 호환, 현재 가장 많이 사용되는 데이터베이스
- PostgreSQL
  - MySQL 다음으로 개발자들이 선호하는 데이터베이스 기술로 널리 인정받고 있음
  - 디스크 조각이 차지하는 영역을 회수할 수 있는 장치는 VACUUM이 특징
  - 지정 시간에 복구하는 기능, 로깅, 접근제어, 중첩된 트랜젝션, 백업 등 할 수 있음

### 4.4.2 NoSQL 데이터베이스
- SQL을 사용하지 않는 데이터베이스

## SECTION5 인덱스
### 4.5.1 인덱스의 필요성
- 데이터를 빠르게 찾을 수 있는 하나의 장치
- 인덱스 설정 시 테이블 안에 내가 찾고자 하는 데이터 빠르게 찾을 수 있음

### 4.5.2 B-트리
- 인덱스는 보통 B-트리라는 자료 구조로 이루어져 있음
- 루드 노드, 리프 노드, 브랜치 노드

- 인덱스가 효율적인 이유와 대수확장성
  - 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 때문
  - 대수확장성
    - 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것
    - 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가

### 4.5.3 인덱스 만드는 방법

### 4.5.4 인덱스 최적화 기법
1. 인덱스는 비용이다.
2. 항상 테스팅하라
3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순

## SECTION6 조인의 종류
- 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것
- MySQL : JOIN
- MongoDB : lookup

### 4.6.1 내부조인
- 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 표기
- 두 테이블 간에 교집합을 나타냄

### 4.6.2 왼쪽 조인
- 왼쪽 테이블의 모든 행이 결과 테이블에 표기
- 테이블 B의 일치하는 부분의 레코드와 함께 테이블 A를 기준으로 완전한 레코드 집합을 생성

### 4.6.3 오른쪽 조인
- 오른쪽 테이블의 모든 행이 결과 테이블로 표기
- 테이블 A에서 일치하는 부분의 레코드와 함께 테이블 B를 기준으로 완전한 레코드 집합 생성

### 4.6.4 합집합 조인
- 두 개의 테이블을 기반으로 조인 조건에 만족하지 않은 행까지 모두 표기
- 양쪽 테이블에서 일치하는 레코드와 함께 테이블 A와 테이블 B의 모든 레코드 집합을 생성

## SECTION7 조인의 원리
### 4.7.1 중첩 루프 조인(NLJ, Nested Loop Join)
- 중첩 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법

### 4.7.2 정렬 병합 조인
- 각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인
- 조인할 때 쓸 적절한 인덱스가 없고 대용량의 테이블들을 조인하고 조인 조건으로 <, > 등 범위 비교 연산자가 있을 때 사용

### 4.7.3 해시 조인
- 해시 테이블을 기반으로 조인하는 방법
- 두 개의 테이블을 조인한다고 했을 때 하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적
- 빌드 단계
  - 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계
- 프로브 단계
  - 레코드 읽기를 시작
  - 각 테이블은 한 번씩만 읽게 되어 중첩해서 두 개의 테이블을 읽는 중첩 루프 조인보다 보통은 성능이 더 좋음
# 1장 요구사항 확인
## 001 소프트웨어 생명 주기
<hr>

### 1. 소프트웨어 생명 주기(Software Life Cycle)
- 소프트웨어 생명 주기는 소프트웨어 개발 방법론의 바탕이 되는 것
- 소프트웨어를 개발하기 위해 정의, 운용, 유지보수 등의 과정을 각 단계별로 나눈 것

<br>

- 소프트웨어 생명 주기는 소프트웨어 개발 단계와 각 단계별 주요 활동, 그리고 활동의 결과에 대한 산출물로 표현, 소프트웨어 수명 주기라고도 함
- (=소프트웨어 프로세스 모형, 소프트웨어 공학 패러다임)
- 폭포수 모형, 프로토타입 모형, 나선형 모형, 애자일 모형 등

### 2. 폭포수 모형(Waterfall Model)
- 소프트웨어 공학에서 가장 오래되고 가장 폭널게 사용된 전통적인 소프트웨어 생명 주기 모형, 고전적 생명 주기 모형
- 선형 순차적 모형 : 개발 과정의 한 단계가 끝나야만 다음단계로 넘어갈 수 있음
- 모형을 적용한 경험과 성공 사례 많음
- 제품의 일부가 될 메뉴얼을 작성해야 함
- 각 단계 끝난 후 다음 단계를 수행하기 위한 결과물이 명확하게 산출되어야 함
- 두 개 이상의 과정이 병행하여 수행되지 않음
- 타당성 검토 -> 계획 -> 요구 분석 -> 설계 -> 구현(코딩) -> 시험(검사) -> 유지보수

### 3. 프로토타입 모형(Prototype Model, 원형 모형)
- 사용자의 요구사항을 정확히 파악하기 위해 실제 개발된 소프트웨어에 대한 견본품(prototype)을 만들어 최종 결과물 예측

<br>

- 시제품은 사용자와 시스템 사이의 인터페이스에 중점 두어 개발
- 시스템의 일부 혹은 시스템의 모형을 만드는 과정으로서 요구된 소프트웨어를 구현하는데, 이는 추후 구현 단계에서 사용될 골격 코드
- 개발 완료시점에서 오류 발견되는 폭포수 모형의 단점 보완하기 윈한 모형
- 요구수집 -> 빠른설계 -> 프로토타입 구축 -> 고객평가 -> 프로토타입 조정 -> 구현

### 4. 나선형 모형(Spiral Model, 점진형 모형)
- 보헴 제안
- 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능 추가한 모형

<br>

- 나선을 따라 돌듯이 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어 개발
- 소프트웨어를 개발하면서 발생할 수 있는 위험 관리, 최소화하는 것 목적
- 계획 -> 분석 -> 개발 -> 평가 / 여러번 반복
- 점직적으로 개발 과정 반복, 누락되거나 추가된 요구사항을 첨가가능, 정밀 -> 유지보수 과정 필요 없음

### 5. 애자일 모형(Agile Model)
- '민첩한', '기민한'
- 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발과정 진행

<br>

- 어느 특정 개발 방법론이 아닌 좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점을 맞춘 방법론
- 기업 활동 전반에 걸쳐 사용
- 스프린트 또는 이터레이션이라고 불리는 짧은 개발 주기 반복, 반복되는 주기마다 만들어지는 결과물에 대한 고객의 평가와 요구 적극 수용
- 각 개발주기에서 고객의 요ㅗ구사항 우선순위 부여, 개발 작업 진행
- 소규모 프로젝트, 고도로 숙달된 개발자, 급변하는 요구사항에 적합
- 애자일 모형 기반 소프트웨어 개발 모형
  - 스크럼
  - XP
  - 칸반
  - Lean
  - 크리스탈
  - ASD
  - 기능 중심 개발
  - DSDM
  - DAD

### 6. 폭포수 모형과 애자일의 비교
|구분|폭포수 모형|애자일|
|---|---|---|
|새로운 요구사항 반영|어려움|지속적으로 반영|
|고객과의 의사소통|적음|지속적임|
|테스트|마지막에 모든 기능 테스트|반복적으로 일정주기가 끝날 때 마다 테스트|
|개발 중심|계획, 문서(메뉴얼)|고객|

## 002 스크럼(Scrum) 기법
<hr>

1. 스크럼의 개요
- 스크럼 : 팀이 중심이 되어 개발의 효율성을 높인다

<br>

- 팀원 스스로가 스크럼 팀을 구성해야 하며, 개발 작업에 관한 모든 것을 스스로 해결할 수 있어야 함

<br>

- 제품 책임자(PO; Product Owner)
    - 이해관계자들 중 개발된 제품에 대한 이해도가 높고, 요구사항을 책임지고 의사 결정할 사람으로 선정
    - 주로 개발 의로자나 사용자가 담당
    - 이혜관계자들의 의견 종합, 제품에 대한 요구사항 작성하는 주체
    - 요구사항이 담긴 백로그 작성, 백로그에 대한 우선순위 지정
      - 백로그 : 제품 개발에 필요한 요구사항을 모두 모아 우선순위를 부여해 놓은 목록
    - 팀원들이 백로그에 스토리 추가 가능, 우선순위 지정불가
    - 테스트 수행하며 주기적으로 요구사항 우선순위 갱신
- 스크럼 마스터(SM; Scrum Master)
    - 스크럼 팀이 스크럼을 잘 수행할 수 있도록 객관적인 시각에서 조언 해주는 가이드 역할
    - 일일 스크럼 회의 주관, 진행 사항 점검, 개발 과정에서 발생된 장애 요소 공론화하여 처리
- 개발팀(DT; Development Team)
  - 제품 책임자와 스크럼 마스터를 제외한 모든 팀원
  - 개발자 외의 다른 팀원들도 해당
  - 보통 최대인원 7~8명

2. 스크럼 개발 프로세스
- 제품 백로그(Product Backlog)⭐
  - 제품 개발에 필요한 모든 요구사항 우선순위에 따라 나열한 목록
  - 지속적 업데이트
  - 제품 백로그 사용자 스토리 기반으로 릴리즈 계획(전체 일정 계획) 수립
- 스프린트(Sprint)⭐
  - 실제 개발 작업을 진행하는 과정, 보통 2~4주 정도의 기간 내에서 진행
  - 속도(Velocity) 추정한 후 개발 담당자에게 할당
  - 할당 시 개발자가 원하는 테스크를 직접 선별하여 담당할 수 있돌고 하는 것이 좋음
  - 할 일(To Do), 진행 중(In Progress), 완료(Done)
- 일일 스크럼 회의(Daily Scrum Meeting)
  - 모든 팀원, 약속된 시간, 약 15분
  - 소멸 차트 사용
  - 스크럼 마스터는 발견된 장애 요소 해결할 수 있도록 도움
- 스프린트 검토 회의(Sprint Review)
  - 부분 또는 전체 완성 제품이 요구사항에 잘 부합되는지 사용자 포함 참석자 앞에서 테스팅 수행
  - 스프린트 한 주 단 한 시간 내에서 진행
  - 제품 책임자는 개선할 사항에 대한 피드백 정리 후 다음 스프린트에 반영할 수 있도록 제품 백로그 업데이트
- 스프린트 회고(Sprint Retrospective)
  - 스프린트 주기 되돌아보며 정해놓은 규칙 잘 준수했는지, 개선할 점은 없는 지 등 확인 및 기록
  - 해당 스프린트가 끝난 시점에서 수행하거나 일정 주기 수행

## 003 XP(eXtreme Programming) 기법
<hr>

### 1. XP(eXtreme Programming)
- 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복 극대화 -> 개발 생산성을 향상시키는 방법

<br>

- 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 빠르게 개발하는 것 목적
- 릴리즈의 기간을 짧게 반복하면서 고객의 요구사항 반영에 대한 가시성 높임
- 릴리즈 테스트마다 고객을 직접 참여
- 비교적 소규모 인원의 개발 프로젝트에 효과적
- 5가지 핵심 가치
  - 의사소통
  - 단순성
  - 용기
  - 존중
  - 피드백

### 2. XP 개발 프로세스
- 사용자 스토리(User Story)
  - 고객 요구사항 간단한 시나리오로 표현
  - 내용은 기능 단위로 구성, 필요한 경우 간단한 테스트 사항 기재
- 릴리즈 계획 수립(Release Planning)
  - 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품 제공하는 것
  - 부분 혹은 전체 개발 완료 시점에 대한 일정 수립
- 스파이크(Spike)
  - 요구사항의 신뢰성 높이고 기술 문제에 대한 위험을 감소시키기 위해 별도로 만드는 간단한 프로그램
  - 처리할 문제 외의 다른 조건은 모두 무시하고 작성
- 이터레이션(iteration)
  - 하나의 릴리즈를 더 세부화 한 단위
  - 일반적으로 1~3주 정도의 기간으로 진행
  - 이 기간 중 새로운 스토리 작성 가능성, 작성된 스토리는 진행 중인 이터레이션 혹은 다음 이터레이션에 포함
- 승인 검사(Acceptance Test, 인수 테스트)
  - 하나의 이터레이션 안에서 계획된 릴리즈 단위의 부분 완료 제품이 구현시 수행하는 테스트
  - 사용자 스토리 작성 시 함께 기재한 테스트 사항에 대하ㅐ 고객이 직접 수행
  - 테스트 과정에서 발견한 오류 사항 다음 이터레이션에 포함
  - 테스트 이후 새로운 요구사항이 작성, 요구사항의 상대적 우선순위가 변경가능
  - 테스트 완료시 다음 이터레이션 진행
- 소규모 릴리즈(Small Release)
  - 릴리즈 소규모로 진행 시 고객의 반은 기능별로 확인, 고객의 요구사항에 좀 더 유연하게 대응 가능
  - 계획된 릴리즈 기간 동안 진행된 이터레이션이 모두 완료시 고객에 의한 최종테스트 수행 후 릴리즈 -> 최종 결과물 고객에게 전달
  - 릴리즈가 최종 완제품이 아닌 경우 다음 릴리즈 일정에 맞게 개발 계속 진행

### **XP의 주요 실천 방법(Practice)
- Pair Programming(짝 프로그래밍)
- Collective Ownership(공동 코드 소유)
- Test-Driven Development(테스트 주도 개발)
- Whole Team(전체 팀)
- Continuous Integration(계속적인 통합)
- Design Improvement, Refactoring(디자인 개선 또는 리팩토링)
- Small Releases(소규모 릴리즈)

## 004 현행 시스템 파악
<hr>

### 1. 현행 시스템 파악 절차
- 새로 개발하려는 시스템의 개발 범위를 명확히 설정하기 위해 현행 시스템의 구성과 제공 기능, 시스템 간의 전달 정보, 사용되는 기술요소, 소프트웨어, 하드웨어 그리고 네트워크의 구성 등을 파악함

### 2. 시스템 구성 파악
- 기간 업무 : 조직의 주요 업무 담당
- 지원 업무 : 기간 업무를 지원하는 업무
- 조직 내에 있는 모든 정보시스템의 현황을 파악할 수 있도록 각 업무에 속하는 단위 업무 정보시스템들의 명칭, 주요 기능들 명시

### 3. 시스템 기능 파악
- 현행 시스템의 기능은 단위 업무 시스템이 현재 제공하는 기능들을 주요 기능과 하부 기능, 세부 기능으로 구분하여 계층형으로 표시

### 4. 시스템 인터페이스 파악
- 현행 시스템의 인터페이스는 단위 업무 시스템 간에 주고받는 데이터의 종류, 형식, 프로토콜, 연계 유형, 주기 등 명시
- 데이터를 어떤 형식으로 주고받는지, 통신규약은 무엇을 사용하는지, 연계 유형은 무엇인지 등을 반드시 고려

### 5. 아키텍처 파악
- 현행 시스템의 아키텍처 구성은 기간 업무 수행에 어떠한 기술 요소들이 사용되는지 최상위 수준에서 계층별로 표현한 아키텍처 구성도로 작성
  - 아키텍처가 단위 업무 시스템별로 다른 경우 가장 핵심이 되는 기간 업무 처리 시스템을 기준으로 표현

### 6. 소프트웨어 구성 파악
- 소프트웨어들의 제품명, 용도, 라이선스 적용 방식, 라이선스 수 등을 명시

### 7. 하드웨어 구성 파악
- 단위 업무 시스템들이 운용되는 서버의 주요 사양과 수량, 그리고 이중화 적용 여부 명시
  - 서버의 이중화 : 기간 업무의 서비스 기간, 장애 대응 정책에 따라 필요 여부 결정
  - 현행 시스템 이중화 적용시 대부분 새로 구성될 시스템에도 이중화가 필요 -> 이로 인한 비용 증가와 시스템 구축 난이도 높아질 가능성 고려

### 8. 네트워크 구성 파악
- 업무 시스템들의 네트워크 구성을 파악할 수 있도록 서버의 위치, 서버 간의 네트워크 연결 방식을 네트워크 구성도로 작성
  - 보안 취약성 분석 -> 적절 대은
  - 네트워크 장애 발생 시 발생 원인을 찾아 복구위한 용도로 활용가능

## 005 개발 기술 환경 파악
<hr>

### 1. 개발 기술 환경의 정의
- 운영체제, 데이터베이스 관리 시스템, 미들웨어 등을 선정할 때 고려해야 할 사항 기술, 오픈 소스 사용 시 주의해야할 내용 제시

### 2. 운영체제(OS, Operating System)
- 컴퓨터 시스템의 자원들을 효율적으로 관리, 사용자가 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어
  - 컴퓨터 사용자 - 컴퓨터 하드웨어 간 인터페이스로서 동작하는 시스템 소프트웨어의 일종 -> 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경 제공
  - ex) Windows, UNIX, Linux, MacOS

### 3. 운영체제 관련 요구사항 식별 시 고려사항
- 가용성
    ```
    - 장시간 운영으로 인해 발생 가능한 고유의 장애 발생 가능성    
    - 메모리 누수로 인한 성능 저하 및 재가동
    - 보안상 발견된 허점을 보완하기 위한 지속적인 패치 설치로 인한 재가동
    - 운영체제의 결함 등으로 인한 패치 설치를 위한 재가동
    ```
- 성능
    ```
    - 대규모 동시 사용자 요청에 대한 처리
    - 대규모 및 대용량 파일 작업에 대한 처리
    - 지원 가능한 메모리 크기
    ```
- 기술 지원
    ```
    - 제작업체의 안정적인 기술 지원
    - 여러 사용자들 간의 정보 공유
    - 오픈 소스 여부(Linux)
    ```
- 주변 기기
    ```
    - 설치 가능한 하드웨어
    - 여러 주변기기 지원 여부
    ```
- 구축비용
    ```
    - 지원 가능한 하드웨어 비용
    - 설치할 응용 프로그램의 라이선스 정책 및 비용
    - 유지관리 비용
    - 총 소유 비용(TCO)
    ```
### 4. 데이터베이스 관리 시스템(DBMS)
- 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보 생성, 데이터베이스관리해주는 소프트웨어
  - 기존 파일 시스템이 갖는 데이터의 종속성과 중복성의 문제 해결하기 위해 제안된 시스템 -> 모든 응용 프로그램들이 데이터베이스를 공용할 수 있도록 관리
  - 데이터베이스의 구성, 접근방법, 유지관리에 대한 모든 책임을 가짐
  - ex) Oracle. IBM DB2, Microsoft SQL Server, MySQL, SQLite, MariaDB, Redis

### 5. DBMS관련 요구사항 식별 시 고려사항
- 가용성
    ```
    - 장시간 운영으로 인해 발생 가능한 고유의 장애 발생 가능성
    - DBMS의 결합 등으로 인한 패치 설치를 위한 재가동
    - 백업이나 복구의 편의성
    - DBMS 이중화 및 복제 지원
    ```
- 성능
    ```
    - 대규모 데이터 처리 기능(분할 테이블 지원 여부)
    - 대용량 트랜잭션 처리 성능
    - 튜닝 옵션의 다양한 지원
    - 최소화된 설정과 비용 기반 질의 최적화 지원
    ```
- 기술 지원
    ```
    - 제작업체의 안정적인 기술 지원
    - 여러 사용자들 간의 정보 공유
    - 오픈 소스 여부
    ```
- 상호 호환성
    ```
    - 설치 가능한 운영체제의 종류
    - JDBC, ODBC와의 호환 여부
    ```
- 구축비용
    ```
    - 라이선스 정책 및 비용
    - 유지관리 비용
    - 총 소유 비용(TCO)
    ```
### 6. 웹 어플리케이션 서버(WAS; Web Applicatioin Server)
- 정적인 콘텐츠 처리를 하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어
  - 데이터 접근, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리 제공
  - 주로 데이터베이스 서버와 연동해서 사용
  - ex) Tomcat, GlassFish, JBoss, Jetty, JEUS, Resin, WebLogic, WebSphere 등


### 7. 웹 어플리케이션 서버 관련 요구사항 식별 시 고려사항
- 가용성
    ```
    - 장시간 운영으로 인해 발생 가능한 고유의 장애 발생 가능성
    - WAS의 결함 등으로 인한 패치 설치를 위한 재가동
    - 안정적인 트랜잭션 처리
    - WAS 이중화 지원 
    ```
- 성능
    ```
    - 대규모 트랜잭션 처리 가능
    - 다양한 설정 옵션 지원
    - 가비지 컬랙션(GC)의 다양한 옵션
    ```
- 기술 지원
    ```
    - 제조업체의 안정적인 기술 지원
    - 여러 사용자들 간의 정보 공유
    - 오픈 소스 여부
    ```
- 구축비용
    ```
    - 라이선스 정책 및 비용
    - 유지관리 비용
    - 총 소유 비용(TCO)
    ```


### 8. 오픈 소스 사용에 따른 고려사항
- 오픈 소스 : 누구나 별다른 제한 없이 사용할 수 있도록 소스 코드를 공개한 것, 오픈 소스 라이선스를 만족하는 소프트웨어
- 라이선스 종류, 사용자 수, 기술의 지속 가능성 고려

## 006 요구사항 정의
<hr>

## 007 요구사항 분석
<hr>

## 008 요구사항 분석 CASE와 HIPO
<hr>


## 009 UML(Unified Modeling Language)
<hr>

## 010 주요 UML 다이어그램
<hr>

# 2장 화면 설계

# 3장 어플리케이션 설계

# 4장 인터페이스 설계
# CHAPTER1 디자인 패턴과 프로그래밍 패러다임
## SECTION1 디자인 패턴
### 1.1 디자인 패턴
- 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 '규약' 형태로 만들어 놓은 것

### 1.1.1 싱글톤 패턴(singleton pattern)
- 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
- 보통 데이터베이스 연결 모듈에 많이 사용
- 장점 : 인스턴스를 생성할 때 드는 비용이 줄어듦
- 단점 : 의존성이 높아짐

#### 데이터 연결 모듈
    - 데이터베이스 연결에 관한 인스턴스 생성 비용을 아낄 수 있음

#### 싱글톤 패턴의 단점
    - TDD(Test Driven Development)를 할 때 걸림돌이 됨
    - 각 테스트마다 '독립적인' 인스턴스를 만들기 어려움

#### 의존성 주입(DI, Dependency Injection)
    - 의존성 (= 종속성)
    - 모듈 간의 결합을 강하게 만들 수 있다는 단점
    - 장점
        (1) 모듈들을 쉽게 교체할 수 있는 구조 -> 테스팅 쉽고, 마이그레이션 수월
        (2) 의존성 방향 일관
        (3) 애플리케이션 쉽게 추론 가능
        (4) 모듈 간의 관계들이 조금 더 명확
    - 단점
        (1) 복잡성 증가
        (2) 약간의 런타임 패널티
    - 의존성 주입 원칙
      - 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 함
      - 둘 다 추상화에 의존해야 함
      - 추상화는 세부 사항에 의존하지 않아야 함

### 1.1.2 팩토리 패턴(Factory Pattern)
- 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴이자 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴
- 느슨한 결합, 더 많은 유연성, 유지 보수성 증가

### 1.1.3 전략 패턴(Strate Pattern)
- (= 정책 패턴, policy pattern)
- 캡슐화한 알고리즘을 컨텍스트안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴

### 1.1.4 옵저버 패턴(Observer Pattern)
- 주체가 어떤 객체(subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴
- 옵저버들 : 이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 '추가 변화 사항'이 생기는 객체들을 의미
- 옵저버 패턴 활용한 서비스 : 트위터
- 주로 이벤트 기반 시스템에 사용 -> MVC패턴에도 사용

### 1.1.5 프록시 패턴과 프록시 서버
#### 프록시 패턴(Proxy Pattern)
    - 대상 객체(subject)에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴
    - 객체의 속성, 변환 등을 보완
    - 보안, 데이터 검증, 캐싱, 로깅에 사용

#### 프록시 서버(Proxy Server)
    - 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램
    - 프록시 서버로 쓰는 nginx
  
#### CORS와 프론트엔드의 프록시 서버
- CORS(Cross-Origin Resource Sharing)는 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘

### 1.1.6 이터레이터 패턴(Iterator Pattern)
- 이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴
- 순회할 수 있는 여러가지 자료형의 구조와는 상관없이 이터레이터라는 하나의 인터페이스로 순회 가능

### 1.1.7 노출모듈 패턴(Revealing Module Pattern)
- 즉시 실행 함수를 통해 private, public같은 접근 제어자를 만드는 패턴

### 1.1.8 MVC 패턴
- 모델(model), 뷰(view), 컨트롤러(controller)로 이루어진 디자인 패턴
- 애플리케이션의 구성 요소를 3가지 역할로 구분
- 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발
- 장점 : 재사용성과 확장성이 용이
- 단점 : 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해짐
- ex) spring

#### 모델
    - 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻함
    - 뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신함
#### 뷰
    - inputbox, checkbox, textarea 등 사용자 인터페이스 요소를 나타냄
    - 모델을 기반으로 사용자가 볼 수 있는 화면
    - 모델이 가지고 있는 정보를 따로 저장하지 않아야함
    - 단순히 사각형 모양 등 화면에 표시하는 정보만 가지고 있어야 함
    - 변경이 일어나면 컨트롤러에 이를 전달해야 함

#### 컨트롤러
    - 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할
    - 이벤트 등 메인 로직을 담당
    - 모델과 뷰의 생명주기 관리

### 1.1.9 MVP 패턴
- MVC패턴으로부터 파생
- MVC에서 C에 해당하는 컨트롤러가 프레젠터(presenter)로 교체된 패턴
- 뷰와 프레젠터는 일대일 관계 -> MVC 패턴보다 더 강한 결합을 지닌 디자인 패턴

### 1.1.10 MVVM 패턴
- MVC에서 C에 해당하는 컨트롤러가 뷰모델로 바뀐 패턴
- 뷰모델은 뷰를 더 추상화한 계층
- MVC패턴과는 다르게 커맨드와 데이터 바인딩을 가지는 것이 특징
- 뷰와 뷰모델 사이의 양방향 데이터 바인딩 지원
- UI를 별도의 코드 수정없이 재사용 가능
- 단위 테스팅하기 쉬움
- ex) Vue.js

## SECTION2 프로그래밍 패러다임
- 프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론
- 선언형 : 함수형
- 명령형 : 객체지향형, 절차지향형

### 1.2.1 선언형과 함수형 프로그래밍
- 선언형 프로그래밍
  - 무엇을 풀어내는가에 집중하는 패러다임
  - 프로그램은 함수로 이루어진 것이다. 라는 명제가 담겨 있는 패러다임
- 함수형 프로그래밍
  - 선언형 패러다임의 일종

### 1.2.2 객체지향 프로그래밍
- OOP, Object-Oriented Programming
- 객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취금하여 객체 내부에 선언된 메서드를 활용하는 방식
- 설계에 많은 시간 소요
- 처리 속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느림
- 객체지향 프로그래밍의 특징
  - 추상화(abstraction)
    - 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것
  - 캡슐화(encapsulation)
    - 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것
  - 상속성(inheritance)
    - 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것
    - 코드의 재사용 측면, 계층적인 관계 생성, 유지 보수성 측면에서 중요
  - 다형성(polymorphism)
    - 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것
    - 오버로딩(overloading)
      - 같은 이름을 가진 메서드를 여러 개 두는 것
      - 컴파일 중 발생하는 '정적' 다형성
    - 오버라이딩(overriding)
      - 주로 메서드 오버라이딩을 말함
      - 상위 클래스로부터 상속받은 메서드를 하위 클랫가 재정의하는 것
      - 런타임 중에 발생하는 '동적' 다형성

#### 설계원칙
- SOLID 원칙
- 단일 책임 원칙(SRP, Single Responsibility Principle)
  - 모든 클래스는 각각 하나의 책임만 가져야 하는 원칙
- 개방-폐쇄 원칙(OCP, Open Closed Principle)
  - 유지 보수 사항이 생긴다면 코드를 쉽게 확장할 수 있도록 하고, 수정할 때는 닫혀 있어야 하는 원칙
  - 기존의 코드는 잘 변경하지 않으면서도 확장을 쉽게 할 수 있어야함
- 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
  - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 하는 것
- 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
  - 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 하는 원칙
- 의존 역전 원칙(DIP, Dependency Inversion Principle)
  - 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 원칙
  - 상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립해야 함

### 1.2.3 절차형 프로그래밍
- 로직이 수행되어야 할 연속적인 계산 과정으로 이루어져 있음
- 장점 : 코드의 가독성이 좋으며 실행 속도가 빠름
- 단점 : 모듈화하기 어렵고 유지 보수성이 떨어짐

### 1.2.4 패러다임의 혼함
- 하나의 패러다임을 기반으로 통일하여 서비스를 구축하는 것도 좋은 생각이지만 여러 패러다임을 조합하여 상황과 맥락에 따라 패러다임 간의 장점만 취해 개발하는 것이 좋음